# 네이버 로그인 구현 업무 지시서

> **작성일**: 2026-01-01
> **작성자**: 시니어 개발자 (10년차)
> **대상자**: 주니어 개발자 (1년차)
> **예상 소요**: 2~3일

---

## 1. 업무 개요

### 1.1 목적

또또앙스 쇼핑몰에 네이버 소셜 로그인 기능을 추가합니다. 현재 카카오 로그인이 구현되어 있으며, 동일한 패턴으로 네이버 로그인을 추가하는 작업입니다.

### 1.2 기대 효과

- 국내 사용자 접근성 향상 (네이버 계정 보유율 높음)
- 회원가입 허들 감소
- 소셜 로그인 옵션 다양화

### 1.3 기술 스택

- **인증 서비스**: Clerk (Custom OAuth Provider)
- **프레임워크**: Next.js 15 + React 19
- **OAuth 프로토콜**: OAuth 2.0 / OIDC

---

## 2. 사전 학습 (필수)

작업 시작 전 아래 내용을 반드시 숙지하세요.

### 2.1 OAuth 2.0 흐름 이해

```
[사용자] → [네이버 로그인 버튼 클릭]
    ↓
[Clerk] → [네이버 인증 페이지로 리다이렉트]
    ↓
[네이버] → [사용자 로그인 및 정보 제공 동의]
    ↓
[네이버] → [Authorization Code를 Clerk로 전달]
    ↓
[Clerk] → [Access Token 발급 및 사용자 정보 조회]
    ↓
[Clerk] → [세션 생성 후 우리 서비스로 리다이렉트]
```

### 2.2 참고할 기존 코드

카카오 로그인 구현을 참고하세요:

- **파일 위치**: `app/sign-in/[[...rest]]/sign-in-content.tsx`
- **핵심 로직**: 1480~1627 라인
- **OAuth 전략**: `oauth_custom_kakao` 형식

### 2.3 네이버 OAuth 엔드포인트

| 항목               | URL                                                      |
| ------------------ | -------------------------------------------------------- |
| Discovery Endpoint | `https://nid.naver.com/.well-known/openid-configuration` |
| Authorization URL  | `https://nid.naver.com/oauth2.0/authorize`               |
| Token URL          | `https://nid.naver.com/oauth2.0/token`                   |
| User Info URL      | `https://openapi.naver.com/v1/nid/me`                    |

---

## 3. 작업 단계

### 3.1 Step 1: 네이버 개발자 센터 설정

#### 3.1.1 애플리케이션 등록

1. [네이버 개발자 센터](https://developers.naver.com) 접속
2. 로그인 → **내 애플리케이션** → **Application 등록**
3. 애플리케이션 정보 입력:
   - **애플리케이션 이름**: 또또앙스
   - **사용 API**: 네이버 로그인 선택

#### 3.1.2 제공 정보 설정 (중요!)

네이버 로그인 API 권한에서 아래 항목을 **필수 동의**로 설정:

- [x] 회원이름 (nickname)
- [x] 이메일 주소 (email) ← **필수! Clerk 사용자 식별에 필요**
- [ ] 프로필 사진 (profile_image) - 선택
- [ ] 성별 (gender) - 선택
- [ ] 생일 (birthday) - 선택

> ⚠️ **주의**: 이메일 미선택 시 Clerk에서 사용자 생성 실패할 수 있음

#### 3.1.3 환경 설정

**PC 웹** 환경 추가:

- **서비스 URL**: `http://localhost:3000` (개발용)
- **Callback URL**: Clerk에서 제공하는 URL (Step 2에서 확인)

#### 3.1.4 발급 정보 저장

- **Client ID**: `XXXXXXXXXXXXXXXXX`
- **Client Secret**: `XXXXXXXXXX`

> 이 값들은 Clerk 대시보드에 입력할 예정입니다. 절대 Git에 커밋하지 마세요!

---

### 3.2 Step 2: Clerk 대시보드 설정

#### 3.2.1 Custom OAuth Provider 추가

1. [Clerk Dashboard](https://dashboard.clerk.com) 접속
2. 프로젝트 선택 → **Configure** → **SSO Connections**
3. **Add connection** → **Custom OAuth provider** 선택

#### 3.2.2 Provider 정보 입력

```
Name: 네이버
Key: naver (← 코드에서 사용할 식별자)
```

#### 3.2.3 OAuth 설정

**방법 A: Discovery Endpoint 사용 (권장)**

```
Discovery Endpoint: https://nid.naver.com/.well-known/openid-configuration
```

**방법 B: 수동 입력 (Discovery 실패 시)**

```
Authorization URL: https://nid.naver.com/oauth2.0/authorize
Token URL: https://nid.naver.com/oauth2.0/token
User Info URL: https://openapi.naver.com/v1/nid/me
```

#### 3.2.4 Client 정보 입력

```
Client ID: [네이버에서 발급받은 ID]
Client Secret: [네이버에서 발급받은 Secret]
```

#### 3.2.5 User Info Mapping 설정 (중요!)

네이버는 사용자 정보를 `response` 객체 안에 반환하므로, Clerk에서 올바르게 매핑해야 합니다.

Clerk 대시보드에서 네이버 provider 편집 → **User Info Mapping** 섹션에서:

```
Email: response.email
Name: response.name
Profile Image: response.profile_image (선택)
User ID: response.id (선택)
```

또는 Advanced Settings에서 JSON Path 형식으로:

- Email: `$.response.email`
- Name: `$.response.name`
- Profile Image: `$.response.profile_image`

> ⚠️ **중요**: 네이버는 `response` 객체 안에 사용자 정보를 반환하므로, 루트 레벨이 아닌 `response.email`, `response.name` 형식으로 매핑해야 합니다.

#### 3.2.6 UserInfo 프록시 서버 설정 (권장)

Clerk의 User Info Mapping이 네이버의 중첩된 JSON 구조를 제대로 처리하지 못하는 경우, 프록시 서버를 사용하여 평탄화된 JSON을 제공할 수 있습니다.

**프록시 서버의 역할:**

- 네이버의 중첩된 JSON (`response` 객체)을 평탄화
- Clerk가 매핑하기 쉬운 flat JSON으로 변환

**AWS EC2에서 프록시 서버 실행:**

1. **프록시 서버 스크립트 확인:**

   ```bash
   # 프로젝트 루트에서
   cat scripts/clerk-userinfo-proxy.js
   ```

2. **환경 변수 설정 (선택):**

   ```bash
   # .env 파일에 추가 (선택사항, 기본값 사용 가능)
   PORT=3001
   NAVER_USERINFO_URL=https://openapi.naver.com/v1/nid/me
   ```

3. **PM2로 프록시 서버 실행:**

   ```bash
   # PM2 설치 (처음 한 번만)
   sudo npm install -g pm2

   # 프록시 서버 시작
   pm2 start scripts/clerk-userinfo-proxy.js --name "clerk-userinfo-proxy"

   # 로그 확인
   pm2 logs clerk-userinfo-proxy

   # 자동 시작 설정
   pm2 save
   pm2 startup
   ```

4. **방화벽 포트 열기 (AWS EC2):**

   ```bash
   # 보안 그룹에서 포트 3001 (또는 설정한 PORT) 인바운드 규칙 추가
   # 또는 ufw 사용 시:
   sudo ufw allow 3001/tcp
   ```

5. **Clerk 대시보드에서 User Info URL 설정:**

   - Custom OAuth Provider 편집
   - **User Info URL**을 프록시 서버 URL로 변경:
     ```
     http://<YOUR_EC2_IP>:3001/
     ```
     또는 도메인이 있다면:
     ```
     https://your-domain.com:3001/
     ```

6. **Clerk 대시보드에서 Attribute Mapping 설정:**
   프록시가 반환한 flat JSON 키 기준으로 매핑:

   | Clerk 필드           | 매핑 키                  |
   | -------------------- | ------------------------ |
   | Identifier / User ID | `sub`                    |
   | Email                | `email`                  |
   | First Name / Name    | `name` 또는 `given_name` |
   | Profile Image        | `picture`                |
   | Email Verified       | `email_verified`         |

**프록시 서버 테스트:**

```bash
# 네이버 access token으로 테스트
curl -H "Authorization: Bearer YOUR_NAVER_ACCESS_TOKEN" \
  http://localhost:3001/
```

**예상 응답 형식:**

```json
{
  "sub": "WhNLW9CXcPmXkEpk-e8vs4pRRgRrhSj009HXFo-2mbQ",
  "email": "ttottoangseu@naver.com",
  "email_verified": true,
  "name": "우수정",
  "given_name": "우수정",
  "family_name": "",
  "picture": "https://ssl.pstatic.net/static/pwe/address/img_profile.png",
  "nickname": null,
  "gender": "F",
  "birthday": "10-03",
  "birthyear": "1978",
  "mobile": "010-4112-6168"
}
```

> ⚠️ **중요**: `sub`와 `email` 필드가 반드시 포함되어 있어야 합니다.

**프록시 서버 관리:**

```bash
# 서버 재시작
pm2 restart clerk-userinfo-proxy

# 서버 중지
pm2 stop clerk-userinfo-proxy

# 서버 삭제
pm2 delete clerk-userinfo-proxy

# 로그 확인
pm2 logs clerk-userinfo-proxy --lines 100
```

#### 3.2.7 Redirect URL 복사

설정 저장 후, Clerk에서 생성된 **Authorized Redirect URL**을 복사합니다.

```
예시: https://your-app.clerk.accounts.dev/v1/oauth_callback
```

#### 3.2.7 네이버 콘솔에 Callback URL 등록

복사한 URL을 네이버 개발자 센터 → 내 애플리케이션 → **Callback URL**에 추가합니다.

> ⚠️ **중요**: URL이 정확히 일치해야 합니다. 오타 주의!

---

### 3.3 Step 3: 프론트엔드 코드 수정

#### 3.3.1 수정할 파일

```
app/sign-in/[[...rest]]/sign-in-content.tsx
```

#### 3.3.2 네이버 버튼 ref 추가

카카오 버튼 ref 선언부 근처에 추가:

```typescript
const naverButtonRef = useRef<HTMLButtonElement>(null);
```

#### 3.3.3 Clerk 자동 생성 네이버 버튼 제거 useEffect 추가

기존 카카오 버튼 제거 로직과 동일한 패턴:

```typescript
// Clerk가 자동으로 생성한 네이버 버튼 삭제
useEffect(() => {
  const removeClerkNaverButton = () => {
    const clerkNaverButton = document.querySelector(
      ".cl-socialButtonsIconButton__custom_naver, button[class*='custom_naver']",
    ) as HTMLElement;

    if (clerkNaverButton) {
      console.log("[SignInContent] Clerk 자동 생성 네이버 버튼 삭제");
      clerkNaverButton.remove();
    }
  };

  const initialTimeout = setTimeout(removeClerkNaverButton, 500);
  const interval = setInterval(removeClerkNaverButton, 1000);

  return () => {
    clearTimeout(initialTimeout);
    clearInterval(interval);
  };
}, []);
```

#### 3.3.4 네이버 버튼 위치 조정 useEffect 추가

카카오 버튼 아래에 네이버 버튼이 위치하도록:

```typescript
// 네이버 버튼을 카카오 버튼 아래에 삽입
useEffect(() => {
  const insertNaverButton = () => {
    const kakaoButton = kakaoButtonRef.current;
    const naverButton = naverButtonRef.current;

    if (kakaoButton && naverButton && kakaoButton.parentElement) {
      // 버튼 스타일 적용
      naverButton.style.cssText += `
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        pointer-events: auto !important;
        cursor: pointer !important;
        z-index: 10 !important;
      `;

      naverButton.removeAttribute("disabled");

      // 카카오 버튼 다음에 삽입
      kakaoButton.parentElement.insertBefore(
        naverButton,
        kakaoButton.nextSibling,
      );
    }
  };

  const initialTimeout = setTimeout(insertNaverButton, 600);
  const interval = setInterval(insertNaverButton, 1000);

  return () => {
    clearTimeout(initialTimeout);
    clearInterval(interval);
  };
}, []);
```

#### 3.3.5 네이버 로그인 버튼 JSX 추가

카카오 버튼 바로 아래에 추가:

```tsx
{
  /* 네이버 로그인 버튼 */
}
<button
  ref={naverButtonRef}
  onClick={async () => {
    console.group("[SignInContent] 네이버 로그인 버튼 클릭");
    console.log("시간:", new Date().toISOString());
    console.log("리다이렉트 URL:", redirectUrl);

    try {
      if (!isLoaded || !signInLoaded) {
        console.warn("[SignInContent] Clerk가 아직 초기화 중입니다.");
        alert("로그인 기능을 준비하는 중입니다. 잠시 후 다시 시도해주세요.");
        console.groupEnd();
        return;
      }

      if (!clerk || !signIn) {
        console.error("[SignInContent] Clerk 또는 signIn이 초기화되지 않음");
        alert("로그인 기능을 준비하는 중입니다. 잠시 후 다시 시도해주세요.");
        console.groupEnd();
        return;
      }

      console.log("[SignInContent] 네이버 로그인 시작");

      // OAuth 전략 시도 (Clerk 설정에 따라 형식이 다를 수 있음)
      const possibleStrategies = [
        "oauth_custom_naver",
        "oauth_custom_custom_naver",
        "oauth_naver",
        "naver",
      ];

      let lastError: any = null;
      const allErrors: string[] = [];

      for (const strategy of possibleStrategies) {
        try {
          console.log(`[SignInContent] 네이버 로그인 시도 - 전략: ${strategy}`);
          await (signIn.authenticateWithRedirect as any)({
            strategy: strategy,
            redirectUrl: redirectUrl,
            redirectUrlComplete: redirectUrl,
          });
          console.log(`[SignInContent] 네이버 로그인 리다이렉트 완료`);
          return;
        } catch (strategyError: any) {
          const errorMsg = strategyError.message || String(strategyError);
          console.warn(`[SignInContent] 전략 ${strategy} 실패:`, errorMsg);
          allErrors.push(`${strategy}: ${errorMsg}`);
          lastError = strategyError;
          continue;
        }
      }

      // 모든 전략 실패
      console.error("[SignInContent] 모든 네이버 로그인 전략 실패:", allErrors);
      throw new Error(
        `네이버 로그인 실패\n\n` +
          `가능한 원인:\n` +
          `1. Clerk 대시보드에서 네이버 Custom OAuth provider가 설정되지 않았습니다.\n` +
          `2. Custom OAuth provider의 Key가 'naver'가 아닙니다.\n` +
          `3. 네이버 개발자 콘솔에서 Callback URL이 등록되지 않았습니다.\n\n` +
          `시도한 전략: ${possibleStrategies.join(", ")}`,
      );
    } catch (error: any) {
      console.error("[SignInContent] 네이버 로그인 실패:", error);

      let errorMessage = "네이버 로그인에 실패했습니다. 다시 시도해주세요.";
      if (error.errors && error.errors.length > 0) {
        errorMessage = error.errors[0].message || errorMessage;
      } else if (error.message) {
        errorMessage = error.message;
      }

      alert(errorMessage);
    } finally {
      console.groupEnd();
    }
  }}
  className="w-full bg-[#03C75A] hover:bg-[#02b351] text-white font-semibold h-8 py-2 rounded-lg transition-all duration-200 shadow-sm hover:shadow-md mb-4 flex items-center justify-center hidden"
  style={{
    backgroundColor: "#03C75A",
    height: "32px",
  }}
>
  네이버 로그인
</button>;
```

#### 3.3.6 네이버 브랜드 가이드라인

- **배경색**: `#03C75A` (네이버 그린)
- **호버색**: `#02b351`
- **텍스트색**: `#FFFFFF` (흰색)

---

## 4. 테스트 체크리스트

### 4.1 기본 동작 테스트

- [ ] 로그인 페이지에 네이버 로그인 버튼이 표시되는가?
- [ ] 버튼 클릭 시 네이버 로그인 페이지로 이동하는가?
- [ ] 네이버 인증 후 우리 서비스로 돌아오는가?
- [ ] 로그인 후 사용자 세션이 정상 생성되는가?

### 4.2 사용자 정보 테스트

- [ ] Clerk 대시보드에서 새 사용자가 생성되었는가?
- [ ] 이메일 정보가 정상적으로 저장되었는가?
- [ ] Supabase users 테이블에 동기화되었는가?

### 4.3 예외 상황 테스트

- [ ] 네이버 로그인 취소 시 에러 메시지가 표시되는가?
- [ ] 정보 제공 동의 거부 시 적절히 처리되는가?
- [ ] Clerk 초기화 전 버튼 클릭 시 안내 메시지가 표시되는가?

### 4.4 UI/UX 테스트

- [ ] 버튼 색상이 네이버 브랜드 가이드라인과 일치하는가?
- [ ] 카카오 버튼과 네이버 버튼 순서가 적절한가?
- [ ] 모바일에서도 버튼이 정상 표시되는가?

---

## 5. 트러블슈팅 가이드

### 5.1 "Invalid redirect_uri" 에러

**원인**: 네이버 콘솔의 Callback URL과 Clerk Redirect URL 불일치
**해결**:

1. Clerk 대시보드에서 Redirect URL 복사
2. 네이버 개발자 센터에 정확히 동일하게 등록
3. 공백, 슬래시 등 오타 확인

### 5.2 "Strategy not found" 에러

**원인**: Clerk 대시보드의 provider key와 코드의 strategy 불일치
**해결**:

1. Clerk 대시보드에서 설정한 Key 확인 (예: `naver`)
2. 코드의 `possibleStrategies` 배열에 해당 형식 포함 여부 확인
3. `oauth_custom_[key]` 형식이 일반적

### 5.3 "User email not provided" 에러

**원인**: 네이버 제공 정보에서 이메일 미선택
**해결**:

1. 네이버 개발자 센터 → 내 애플리케이션
2. 네이버 로그인 → 제공 정보 설정
3. "이메일 주소" 필수 동의로 변경

### 5.4 버튼이 화면에 안 보임

**원인**: useEffect의 DOM 조작 타이밍 이슈
**해결**:

1. `setTimeout` 지연 시간 증가 (500ms → 1000ms)
2. 브라우저 개발자 도구에서 버튼 요소 존재 여부 확인
3. `hidden` 클래스가 제거되었는지 확인

---

## 6. 제출물

작업 완료 후 아래 항목을 제출해주세요:

### 6.1 코드 관련

- [ ] PR (Pull Request) 생성
- [ ] 변경된 파일 목록 및 설명

### 6.2 설정 관련

- [ ] 네이버 개발자 센터 설정 스크린샷
- [ ] Clerk 대시보드 설정 스크린샷 (Client Secret 가림)

### 6.3 테스트 관련

- [ ] 테스트 체크리스트 완료 여부
- [ ] 네이버 로그인 성공 화면 스크린샷

---

## 7. 일정 계획

| 일차  | 오전                          | 오후                |
| ----- | ----------------------------- | ------------------- |
| 1일차 | 네이버 개발자 센터 앱 등록    | Clerk 대시보드 설정 |
| 2일차 | 프론트엔드 코드 수정          | 기본 동작 테스트    |
| 3일차 | 예외 상황 테스트 및 버그 수정 | 문서화 및 PR 제출   |

---

## 8. 참고 자료

- [네이버 로그인 API 문서](https://developers.naver.com/docs/login/overview/overview.md)
- [Clerk Custom OAuth 문서](https://clerk.com/docs/authentication/social-connections/custom-oauth)
- [기존 카카오 로그인 구현 코드](../app/sign-in/[[...rest]]/sign-in-content.tsx)
- [팀장 작성 가이드라인](./naver-clerk.md)

---

## 9. 질문 및 지원

작업 중 막히는 부분이 있으면:

1. 먼저 트러블슈팅 가이드 확인
2. 공식 문서 검색
3. 그래도 해결 안 되면 팀장에게 질문

> **팁**: 에러 메시지 전문과 시도한 해결 방법을 함께 공유하면 더 빠른 지원이 가능합니다.

---

**작성 완료. 화이팅! 🚀**
